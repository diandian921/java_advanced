1、分别用 100 个字以上的一段话，加上一幅图 (架构图或脑图)，总结自己对下列技术的关键点思考和经验认识: 

思维导图：
    [java.xmind](java.xmind)

1)JVM

Java语言具有跨平台的特性，也正是因为JVM的存在。Java源文件被编译成字节码，被虚拟机加载后执行。这里隐含的意思有两层：
1）大部分情况下，编程者只需要关心Java语言本身，而无需特意关心底层细节。包括对内存的分配和回收，也全权交给了GC。
2）对于虚拟机而言，只要是符合规范的字节码，它们都能被加载执行，当然，能正常运行的程序光满足这点是不行的，程序本身需要保证在运行时不出现异常。所以，Scala、Kotlin、Jython等语言也可以跑在虚拟机上。
围绕虚拟机的效率问题展开，将涉及到一些优化技术，例如：JIT、AOT。因为如果虚拟机加载字节码后，完全进行解释执行，这势必会影响执行效率。所以，对于这个运行环节，虚拟机会进行一些优化处理，例如JIT技术，会将某些运行特别频繁的代码编译成机器码。而AOT技术，是在运行前，通过工具直接将字节码转换为机器码。

2)NIO

NIO（Non-blocking I/O，也称为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。
Java中提供的api是Selector,他是依赖操作系统的，不同的操作系统实现也不一样，通常linux下是用epoll实现的。



3)并发编程
这些年，我们的 CPU、内存、I/O 设备都在不断迭代，不断朝着更快的方向努力。但是，在这个快速发展的过程中，有一个核心矛盾一直存在，就是这三者的速度差异。
在解决这个核心矛盾的同时，引入了可见性、原子性和有序性问题，这三个问题就是很多并发程序的 Bug 之源。 java内存模型解决了可见性和有序性问题，互斥锁解决了原子性问题。 虽说互斥锁是解决并发问题的核心工具，但它也可能会带来死锁问题，这就需要线程间的协作(常见的有等待-通知)。

4)Spring 和 ORM 等框架

我们平时所讲的Spring，其实是狭义的Spring Framework，其内部包含了依赖注入、事件机制等核心模块，也包括事务、O/R Mapping 等功能组成的数据访问模块，以及 Spring MVC 等 Web 框架和其他基础组件。
广义上的 Spring 已经成为了一个庞大的生态系统，例如：
Spring Boot，通过整合通用实践，更加自动、智能的依赖管理等，Spring Boot 提供了各种典型应用领域的快速开发基础，所以它是以应用为中心的一个框架集合。
Spring Cloud，可以看作是在 Spring Boot 基础上发展出的更加高层次的框架，它提供了构建分布式系统的通用模式，包含服务发现和服务注册、分布式配置管理、负载均衡、分布式诊断等各种子系统，可以简化微服务系统的构建。
当然，还有针对特定领域的 Spring Security、Spring Data 等。


ORM 即Object-Relationl Mapping，它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了。
常用的orm框架有mybatis和hibernate.

5)MySQL 数据库和 SQL
mysql是OLTP场景下流行的数据库，支持ACID，完善的隔离级别和MVCC机制保证了不同场景下的数据一致性要求。
mysql的innodb引擎适合写多读少的场景，myisam引擎适合读多写少场景


6)分库分表

分表解决了单表查询性能问题，分库解决了两个问题：垂直拆分（使得高并发业务用单独的库维护互不影响）；水平拆分（数据量大的库可以进一步拆分成多库解决查询性能瓶颈）。
当磁盘IO读写压力大时，分库比分表好。分库可以将数据分散到不同的数据库实例，使用不同的磁盘，可以提高整个集群的并行数据处理能力。
分表的方法按分配策略常见的可以分为：hash取模、按主键的范围（如0～100万、100万～200万）。分库一般分为：按业务划分、按机器负载划分。
shardingsphere-jdbc提供了丰富的路由分配策略可以灵活定义分库分表的划分策略。

7)RPC 和微服务

RPC（远程过程调用）允许调用另一个地址空间的函数，隐藏了网络通信的具体实现，可以像调用本地函数一样调用远程函数获得返回结果。微服务相比RPC
增加了业务语义，偏向于基于业务提供独立的服务。
微服务提供了分布式服务化，每个微服务可以定义服务名称，通过注册中心提供服务注册、发现，使微服务之间可以使用服务名+接口地址的方式点对点通信。
配置中心集中化远程存储微服务的各项业务或代码参数配置，可以使得在多个微服务间共享配置。
Spring Cloud框架给java微服务生态提供了网关及路由、负载均衡、熔断等技术。feign集成了ribbon实现了客户端http接口调用和负载均衡，通过
低代码实现了接口调用。熔断和降级使用hstrix配置，流控方面可以使用阿里的Sentinel。
微服务治理可以借助skywalking做链路追踪和Prometheus等。

8)分布式缓存
    但随着并发的增加，存储数据量的增多，数据库的磁盘 IO 逐渐成了系统的瓶颈，我们需要一种访问更快的组件来降低请求响应时间，提升整体系统性能。这时我们就会使用缓存。
    缓存，是一种存储数据的组件，它的作用是让对数据的请求更快地返回。
    缓存的主要作用是提升访问速度，从而能够抗住更高的并发。但是他也有一些不足：
    首先，缓存比较适合于读多写少的业务场景，并且数据最好带有一定的热点属性。
    其次，缓存会给整体系统带来复杂度，并且会有数据不一致的风险。
    再次，之前提到缓存通常使用内存作为存储介质，但是内存并不是无限的。
    最后，缓存会给运维也带来一定的成本，比如要做到缓存的高可用等。
    另外还有，缓存穿透，缓存击穿，缓存雪崩等等，需要我们在使用时特别注意。


9)分布式消息队列

消息队列的本质是将同步处理转成异步处理，异步会带来相应的好处，但也有弊端。
Pros:
1.可在模块、服务、接口等不同粒度上实现解耦
2.订阅/消费模式也可在数据粒度上解耦
3.可提高系统的并发能力，集中力量办大事(同步部分)，碎片时间做小事(异步部分)
4.可提高系统可用性，因为缓冲了系统负载

Cons:
1.降低了数据一致性，如要保持强一致性，需要高代价的补偿(如分布式事务、对账)
2.有数据丢失风险，如宕机重启，如要保证队列数据可用，需要额外机制保证(如双活容灾)

总体来说，消息队列的适用场景还是很多的，如秒杀、发邮件、发短信、高并发订单等，
不适合的场景如银行转账、电信开户、第三方支付等。关键还是要意识到消息队列的优劣点，然后分析场景是否适用。

