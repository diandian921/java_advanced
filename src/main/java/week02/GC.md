# JVM内存及GC总结

## 1 JVM内存规范
根据JVM规范，JVM把内存划分为以下几部分：
- 方法区（Method Area）
- 堆(Heap)
- 虚拟机栈
- 本地方法栈
- 程序计数器

### 1.1 方法区（Method Area）

    在Hotspot虚拟机中，这块区域在java8之前对应Permanent Generation，java8之后对应metaspace。
    方法区存放了要加载的类的信息（如类名、修饰符等）、静态变量、构造函数、final定义的常量、类中的字段和方法等信息。方法区是全局共享的，在一定条件下也会被GC。当方法区超过它允许的大小时，就会抛出OutOfMemory：PermGen Space（java8之前）Metaspace（java8及之后）异常。
    运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译器生成的常量和引用。一般来说，常量的分配在编译时就能确定，但也不全是，也可以存储在运行时期产生的常量。


### 1.2 堆区（Heap）

    堆区是对象诞生的地方，也是GC的主战场。堆区由所有线程共享，在虚拟机启动时创建。
    可以用Xmx,Xms来指定堆区的大小，通常建议将两者的值设置为一样的。
    堆区的内存划分又可以根据不同的gc算法有不同的划分方式。

### 1.3 虚拟机栈（VM Stack）

    每个线程对应一个虚拟机栈，它是线程私有的，生命周期和线程一样，每个方法被执行时产生一个栈帧（Stack Frame），栈帧用于存储局部变量表、动态链接、操作数和方法出口等信息，当方法被调用时，栈帧入栈，当方法调用结束时，栈帧出栈。
    可以用Xss设置每个线程栈的大小。

### 1.4 本地方法栈（Native Method Stack）

    本地方法栈用于支持native方法的执行，存储了每个native方法的执行状态。本地方法栈和虚拟机栈他们的运行机制一致，唯一的区别是，虚拟机栈执行Java方法，本地方法栈执行native方法。

### 1.5 程序计数器（Program Counter Register）

    程序计数器的作用是：存储当前线程执行的字节码行号。它是线程私有的。

## 2 GC机制
    随着程序的运行，内存中的实例对象、变量等占据的内存越来越多，如果不及时进行回收，会降低程序运行效率，甚至引发系统异常。
    在上面的五个内存区域中，有3个是不需要进行垃圾回收的：本地方法栈、程序计数器、虚拟机栈。因为他们的生命周期是和线程同步的，随着线程的销毁，他们占用的内存会自动释放。所以，只有方法区和堆区需要进行垃圾回收。

### 2.1 查找算法
    要进行垃圾回收，首先就是要找到哪些对象是需要被回收的。通常有两种算法：引用计数法和根搜索算法。

#### 引用计数算法
    经典的引用计数算法，每个对象添加到引用计数器，每被引用一次，计数器+1，失去引用，计数器-1，当计数器在一段时间内为0时，即认为该对象可以被回收了。
    但是这个算法有个明显的缺陷：当两个对象相互引用，但是二者都已经没有作用时，理应把它们都回收，但是由于它们相互引用，不符合垃圾回收的条件，所以就导致无法处理掉这一块内存区域。
#### 根搜索算法
    由于引用计数算法的缺陷，因此，Hotspot的JVM并没有采用这种算法，而是采用一个叫——根搜索算法。
    基本思想是：从一个叫GC Roots的根节点出发，向下搜索，如果一个对象不能达到GC Roots的时候，说明该对象不再被引用，可以被回收。

### 2.2 GC算法
    常见的GC算法：复制、标记-清除和标记-压缩。

#### 复制算法
    复制算法采用的方式为从根集合进行扫描，将存活的对象移动到一块空闲的区域。当存活的对象较少时，复制算法会比较高效，其带来的成本是需要一块额外的空闲空间和对象的移动。

#### 标记-清除
    该算法采用的方式是从跟集合开始扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，并进行清除。
    标记-清除算法不需要移动对象，且仅对不存活的对象进行清理，在空间中存活对象较多的时候，效率较高，但由于只是清除，没有重新整理，因此会造成内存碎片。

#### 标记-压缩
    该算法与标记-清除算法类似，都是先对存活的对象进行标记，但是在清除后会把活的对象向左端空闲空间移动，然后再更新其引用对象的指针。
    由于进行了移动规整动作，该算法避免了标记-清除的碎片问题，但由于需要进行移动，因此成本也增加了。

## 3 垃圾收集器

### 3.1 分代收集器
    分代假说：大部分对象是朝生夕灭的，熬过越多次GC过程的对象就越难以消亡。
    基于分代假说：堆内存分为新生代、老年代。其中新生代又分为Eden区和Survivor区，Survivor区又分为大小相同的两部分：FromSpace和ToSpace。
    基于该模式的垃圾收集器有：Serial收集器、Serial old收集器、ParNew收集器、Parallel Old收集器、Parallel Scavenge收集器、CMS收集器。

#### 3.1.1 Serial GC
    Serial GC是最古老也是最基本的收集器，比较适合于只有一个处理器的系统。在串行处理器中minor和major GC过程都是用一个线程进行回收的。
    它的最大特点是在进行垃圾回收时，需要对所有正在执行的线程暂停（stop the world），对于有些应用是难以接受的。
    该收集器适用于单CPU、新生代空间较小且对暂停时间要求不是特别高的应用上，是client模式的默认GC方式。
    
#### 3.1.2 ParNew GC
    基本和Serial GC一样，但本质区别是加入了多线程机制，提高了效率，这样它就可以被用于服务端上（server），同时它可以与CMS GC配合，所以，更加有理由将他用于server端。

#### 3.1.3 Parallel Scavenge GC
    在整个扫描和复制过程采用多线程的方式进行，适用于多CPU、对暂停时间要求较短的应用，是server级别的默认GC方式。

#### 3.1.4 Serial Old收集器
    Serial Old是Serial收集器的老年代版本，它同样使用一个单线程执行收集，使用“标记-整理”算法。主要使用在Client模式下的虚拟机。

#### 3.1.5 Parallel Old收集器
    Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。

#### 3.1.6 CMS (Concurrent Mark Sweep)收集器
    该收集器的目标是解决Serial GC停顿的问题，以达到最短回收时间。常见的B/S架构的应用就适合这种收集器，因为其高并发、高响应的特点，CMS是基于标记-清除算法实现的。
    CMS收集器的优点：并发收集、低停顿，但远没有达到完美；
    CMS收集器的缺点：
    a.CMS收集器对CPU资源非常敏感，在并发阶段虽然不会导致用户停顿，但是会占用CPU资源而导致应用程序变慢，总吞吐量下降。
    b.CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”，失败而导致另一次的Full GC。
    c.CMS收集器是基于标记-清除算法的实现，因此也会产生碎片。

### 3.2 G1(Garbage First)
    G1相较于CMS收集器有不少改进，首先，其基于标记-压缩算法，不会产生内存碎片，其次可以比较精确的控制停顿。
    G1打破了以往的的内存划分模式，G1将堆空间划分为了若干个大小相同的区域，即Region。
    Region又分为四种类型：Eden、Survivor、Old、Humongous。其中humongous是特殊的old类型，专门放置大型的对象。
    G1在回收的时候优先回收垃圾最多的区域，这也为什么叫做Garbage First的原因。
    G1的一大优势就在于可预测的停顿时间，在可预测的时间内能够尽快完成垃圾回收。
    G1之所以采用了分代+分区的做法来源于G1垃圾回收器的理念，追求吞吐率与最大STW之间的平衡。相对而言，G1在同存空间利用率上做了较大的妥协，因为RememberSet相
    相对来说是非常复杂的，其大小约为堆空间的20%。
### 3.3 Shenandoah
    Shenandoah最早由Red Hat公司发起，目标是利用现代多核CPU的优势，降低大堆内存在垃圾回收时产生的停顿时间。
    它和G1类似，都是基于Region的内存布局，都有用于存放大对象的Humongous Region,默认回收策略也是优先处理回收价值最大的Region.
    而相对于G1，Shenandoah是不分代的，Shenandoah 使用Connection Matrix记录了跨Region的引用关系，替换掉了G1的Remembered Set,内存和计算成本更低。
### 3.4 ZGC
    ZGC的目标是在尽可能对单位时间内GC吞吐量不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集器停顿的时间限制在10ms以内。
    ZGC是一款基于可变Region内存区域，使用了读屏障、染色指针和内存多重映等技术实现了可并发的标记-压缩算法的垃圾收集器。

